# -*- coding: utf-8 -*-
"""Flujo de una particula Modelo + colision

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1QEYFqpeJlAmeK6dzKAKiaAriOh8RgnOa

# Importacion de librerias
"""

from datetime import datetime
import time
import math
import json
import random
import os
from turtle import distance
import numpy as np
import tensorflow as tf
import threading

from math import *

from bokeh.plotting import figure, show
from bokeh.io import output_notebook

"""## Load Models"""

left_model = tf.keras.models.load_model('left_model_2')
right_model = tf.keras.models.load_model('right_model_2')

foto ="a.png"
tf.keras.utils.plot_model(left_model, to_file=foto, show_shapes=True)
def execute_flow(gamab_max, gamab_min, titab_max, titab_min, TIME_LIMIT, NUM_Particules):
    # Base Path

    base_left_path_data = {
        0.0: {'y': 0.020882013129210387, 'z': 0.02378285024643772},
        0.01: {'y': 0.05899288996039536, 'z': 0.07338496215822628},
        0.02: {'y': 0.09664279298279023, 'z': 0.12175046063108381},
        0.03: {'y': 0.12942794847747136, 'z': 0.16380685596847253},
        0.04: {'y': 0.15719705570213868, 'z': 0.1997769580835076},
        0.05: {'y': 0.18323400819879043, 'z': 0.23329517947277317},
        0.06: {'y': 0.20738548363211728, 'z': 0.2642780260469205},
        0.07: {'y': 0.22976936095948208, 'z': 0.2929607629137783},
        0.08: {'y': 0.25076775362702225, 'z': 0.31978800459145795},
        0.09: {'y': 0.2704178509920392, 'z': 0.34489134498513013},
        0.1: {'y': 0.29000788699142, 'z': 0.36950199534812483},
        0.11: {'y': 0.30796331045382214, 'z': 0.39219656099283623},
        0.12: {'y': 0.3255000485168959, 'z': 0.4141328821866608},
        0.13: {'y': 0.3423650957723031, 'z': 0.4350913145248715},
        0.14: {'y': 0.35821080014824525, 'z': 0.4548203892187333},
        0.15: {'y': 0.37419929122444345, 'z': 0.4743494855571214},
        0.16: {'y': 0.3887424233413135, 'z': 0.4923145545858361},
        0.17: {'y': 0.4033433306693547, 'z': 0.5100757767784435},
        0.18: {'y': 0.4174602918266625, 'z': 0.5271373437555968},
        0.19: {'y': 0.4310404139076288, 'z': 0.5435006728643752},
        0.2: {'y': 0.44438922266930747, 'z': 0.5593942845561267},
        0.21: {'y': 0.45744355627208666, 'z': 0.5748068012764893},
        0.22: {'y': 0.4696045438853837, 'z': 0.5892797644558891},
        0.23: {'y': 0.48191300243497237, 'z': 0.603614152462473},
        0.24: {'y': 0.4939874918029554, 'z': 0.6175470064002002},
        0.25: {'y': 0.5057144667852737, 'z': 0.6310041161538309},
        0.26: {'y': 0.5162380962755587, 'z': 0.6433722934531582},
        0.27: {'y': 0.5279953776919385, 'z': 0.6564165763032335},
        0.28: {'y': 0.5386181687109455, 'z': 0.6684370905528176},
        0.29: {'y': 0.5492314038492252, 'z': 0.680242277335057},
        0.3: {'y': 0.5595504043198554, 'z': 0.6916709782731928},
        0.31: {'y': 0.5697018605485682, 'z': 0.7027280398429543},
        0.32: {'y': 0.5798627290570398, 'z': 0.7136577775601947},
        0.33: {'y': 0.5889509607137952, 'z': 0.7237206000815241},
        0.34: {'y': 0.598975388107724, 'z': 0.7341869028815711},
        0.35: {'y': 0.6080420925307691, 'z': 0.743852499238723},
        0.36: {'y': 0.617289672460764, 'z': 0.7534585560499144},
        0.37: {'y': 0.6263418841291257, 'z': 0.7627901754042008},
        0.38: {'y': 0.6348449817002331, 'z': 0.7716207080997566},
        0.39: {'y': 0.644191277633128, 'z': 0.780795256773385},
        0.4: {'y': 0.6521224403898271, 'z': 0.7889588145519064},
        0.41: {'y': 0.6608238508665882, 'z': 0.7974200194720907},
        0.42: {'y': 0.6683419463287693, 'z': 0.8050603300656258},
        0.43: {'y': 0.6771658468994671, 'z': 0.8132865424119645},
        0.44: {'y': 0.6847751754118266, 'z': 0.8206759988786332},
        0.45: {'y': 0.6929373292765164, 'z': 0.8282126987115287},
        0.46: {'y': 0.7003986403033429, 'z': 0.8352489863083167},
        0.47: {'y': 0.7084259672791046, 'z': 0.8424270524155819},
        0.48: {'y': 0.7152273385316212, 'z': 0.8488513080707364},
        0.49: {'y': 0.7231089537233821, 'z': 0.8556656666017173},
        0.5: {'y': 0.7298550425690086, 'z': 0.8617743602579268},
        0.51: {'y': 0.7373741003304288, 'z': 0.8681507212236454},
        0.52: {'y': 0.744488536596092, 'z': 0.8741672711879536},
        0.53: {'y': 0.7509869961596598, 'z': 0.8797914671880072},
        0.54: {'y': 0.7583481832679927, 'z': 0.885671440402613},
        0.55: {'y': 0.7648776700189216, 'z': 0.8910413858585382},
        0.56: {'y': 0.7713732011598522, 'z': 0.8962988162256763},
        0.57: {'y': 0.7782357646060021, 'z': 0.9015547299331482},
        0.58: {'y': 0.7846502327519328, 'z': 0.9065037894990979},
        0.59: {'y': 0.7910976702661203, 'z': 0.9113457021832692},
        0.6: {'y': 0.7973188777748079, 'z': 0.915978835191682},
        0.61: {'y': 0.8035432474835368, 'z': 0.9204909409808286},
        0.62: {'y': 0.8094799758693922, 'z': 0.9247745696752468},
        0.63: {'y': 0.8158248332546298, 'z': 0.9290985613253405},
        0.64: {'y': 0.8217652845315077, 'z': 0.9331668191643141},
        0.65: {'y': 0.8278296927090458, 'z': 0.937139205059212},
        0.66: {'y': 0.8336260563689034, 'z': 0.9409312721655074},
        0.67: {'y': 0.8395414462401966, 'z': 0.9446218894525249},
        0.68: {'y': 0.8450836971461197, 'z': 0.9480818561550389},
        0.69: {'y': 0.8508086133928064, 'z': 0.9515044456389188},
        0.7: {'y': 0.8565121299789006, 'z': 0.9548066743413435},
        0.71: {'y': 0.8619851761541378, 'z': 0.957919382093515},
        0.72: {'y': 0.8672559554140457, 'z': 0.9608685187050178},
        0.73: {'y': 0.8728393667661842, 'z': 0.9638105904304418},
        0.74: {'y': 0.8782391304016158, 'z': 0.9665860514914367},
        0.75: {'y': 0.8833542733300846, 'z': 0.9691781730692308},
        0.76: {'y': 0.8888332601075459, 'z': 0.9717603146613305},
        0.77: {'y': 0.8937923090769417, 'z': 0.9741091287206006},
        0.78: {'y': 0.8989746663566544, 'z': 0.9764146520423103},
        0.79: {'y': 0.9040883109450264, 'z': 0.9786036984455175},
        0.8: {'y': 0.9091979625005484, 'z': 0.9806787808901082},
        0.81: {'y': 0.9140881421252504, 'z': 0.982614983746068},
        0.82: {'y': 0.9189699715875801, 'z': 0.9844428880166705},
        0.83: {'y': 0.9238968493886105, 'z': 0.9861865099378117},
        0.84: {'y': 0.9287129505258944, 'z': 0.9877977909672302},
        0.85: {'y': 0.9335523792080698, 'z': 0.9893257710752078},
        0.86: {'y': 0.9382644845271424, 'z': 0.9907306703086514},
        0.87: {'y': 0.9428409236972478, 'z': 0.9920194720552356},
        0.88: {'y': 0.9475662456817643, 'z': 0.9932358363058162},
        0.89: {'y': 0.9521499444911175, 'z': 0.9943341156951967},
        0.9: {'y': 0.9566573021541434, 'z': 0.9953304113280916},
        0.91: {'y': 0.9612578360186742, 'z': 0.9962330222320337},
        0.92: {'y': 0.9656338815088836, 'z': 0.9970271548608579},
        0.93: {'y': 0.970209515931016, 'z': 0.997743414641438},
        0.94: {'y': 0.9744759416024606, 'z': 0.9983367506343163},
        0.95: {'y': 0.978764527225767, 'z': 0.9988417839421463},
        0.96: {'y': 0.9830286334753543, 'z': 0.9992558855490093},
        0.97: {'y': 0.9873983876800825, 'z': 0.9995838335972068},
        0.98: {'y': 0.9915862813033391, 'z': 0.9998124834870038},
        0.99: {'y': 0.9958507329306053, 'z': 0.9999509762909212},
    }
    base_right_path_data = {
        0.0: {'y': 0.0051888440523463674, 'z': 0.9999965237452075},
        0.01: {'y': 0.017324551388850997, 'z': 0.9999627698076634},
        0.02: {'y': 0.033980089184739735, 'z': 0.9998628521310766},
        0.03: {'y': 0.05082842577348937, 'z': 0.9996931656138562}, 0.04: {'y': 0.06785207039429492, 'z': 0.9994537505255622}, 0.05: {'y': 0.08422935365756523, 'z': 0.9991537257215725}, 0.06: {'y': 0.10071667867358877, 'z': 0.9987837213632536}, 0.07: {'y': 0.11716294144990444, 'z': 0.998348566330621}, 0.08: {'y': 0.13325469245649418, 'z': 0.9978505305562536}, 0.09: {'y': 0.14943396814482718, 'z': 0.9972835425585846}, 0.1: {'y': 0.1655928256614333, 'z': 0.9966522489434935}, 0.11: {'y': 0.18104544274252113, 'z': 0.9959697811043096}, 0.12: {'y': 0.1972657102692396, 'z': 0.9952016946650734}, 0.13: {'y': 0.21289647872347767, 'z': 0.99438201539332}, 0.14: {'y': 0.22798800339497707, 'z': 0.9935153827966915}, 0.15: {'y': 0.2438531234737811, 'z': 0.9925572203775498}, 0.16: {'y': 0.25889737087970266, 'z': 0.9915605674642521}, 0.17: {'y': 0.27377703645044343, 'z': 0.9905085646085305}, 0.18: {'y': 0.2893443341561889, 'z': 0.9893630648391192}, 0.19: {'y': 0.3039960964007792, 'z': 0.9881939098521768}, 0.2: {'y': 0.3191938348742065, 'z': 0.9869332151545213}, 0.21: {'y': 0.33364376468350376, 'z': 0.9856356087915423}, 0.22: {'y': 0.3485891451254767, 'z': 0.9842617668570885}, 0.23: {'y': 0.3631702029811051, 'z': 0.9828396238588442}, 0.24: {'y': 0.37714697969293853, 'z': 0.9813865362576194}, 0.25: {'y': 0.39181798832170533, 'z': 0.9798247814182305}, 0.26: {'y': 0.40620401234726305, 'z': 0.9782288243856773}, 0.27: {'y': 0.4206450847564761, 'z': 0.9765569891018274}, 0.28: {'y': 0.43383406714695755, 'z': 0.9749053543568479}, 0.29: {'y': 0.44827699668119264, 'z': 0.9731024320516573}, 0.3: {'y': 0.462103432114717, 'z': 0.971278084901242}, 0.31: {'y': 0.47627954199242056, 'z': 0.9693808869047078}, 0.32: {'y': 0.48934756631198184, 'z': 0.9674923456668341}, 0.33: {'y': 0.5036300498599768, 'z': 0.9654541255822702}, 0.34: {'y': 0.5161485635565659, 'z': 0.9634852526563636}, 0.35: {'y': 0.530989726158915, 'z': 0.9612744062036248}, 0.36: {'y': 0.5434481298460023, 'z': 0.9591972197548104}, 0.37: {'y': 0.5568890011725443, 'z': 0.9569701372013865}, 0.38: {'y': 0.5700539495128062, 'z': 0.9547211710645412}, 0.39: {'y': 0.5833464706201408, 'z': 0.9523744223713072}, 0.4: {'y': 0.5961885302342541, 'z': 0.9500429054520735}, 0.41: {'y': 0.6090839285696047, 'z': 0.9476075073840087}, 0.42: {'y': 0.6221978630615065, 'z': 0.945124289768478}, 0.43: {'y': 0.634611108921822, 'z': 0.9426234878379803}, 0.44: {'y': 0.6475984375592011, 'z': 0.9400406595201085}, 0.45: {'y': 0.6597284224825589, 'z': 0.9374384989713267}, 0.46: {'y': 0.6733289098235452, 'z': 0.9346550309014539}, 0.47: {'y': 0.6845052279915075, 'z': 0.9320661940662184}, 0.48: {'y': 0.6983616387370789, 'z': 0.929119433275057}, 0.49: {'y': 0.7095441315773677, 'z': 0.9264317492861733}, 0.5: {'y': 0.7221385996351971, 'z': 0.9234974819302322}, 0.51: {'y': 0.7341874989128063, 'z': 0.9205940007992811}, 0.52: {'y': 0.7463627652942056, 'z': 0.9175637859025896}, 0.53: {'y': 0.7586467052533884, 'z': 0.9145362117697119}, 0.54: {'y': 0.7699506877703702, 'z': 0.9115253702281328}, 0.55: {'y': 0.7830018548832125, 'z': 0.9082310094636301}, 0.56: {'y': 0.7940966182644139, 'z': 0.9051741723278678}, 0.57: {'y': 0.8055039995804335, 'z': 0.9019643789881339}, 0.58: {'y': 0.818177944700821, 'z': 0.8985749268171626}, 0.59: {'y': 0.8289535276817508, 'z': 0.895355407465796}, 0.6: {'y': 0.8404611604483617, 'z': 0.8920004602484918}, 0.61: {'y': 0.8525362919637958, 'z': 0.8884999978006515}, 0.62: {'y': 0.863840110077045, 'z': 0.8850202779301068}, 0.63: {'y': 0.8749432653948179, 'z': 0.8815531289649049}, 0.64: {'y': 0.8864433375975002, 'z': 0.8779598145574911}, 0.65: {'y': 0.8976870578575962, 'z': 0.8743419799185628}, 0.66: {'y': 0.9093090929569061, 'z': 0.87063537286361}, 0.67: {'y': 0.9189546249044339, 'z': 0.8671697027990652}, 0.68: {'y': 0.9312242579439873, 'z': 0.863199888710445}, 0.69: {'y': 0.9413429730449877, 'z': 0.8595526158663236}, 0.7: {'y': 0.9529930649031757, 'z': 0.8556046442089124}, 0.71: {'y': 0.963851257413764, 'z': 0.8517120836423963}, 0.72: {'y': 0.9746164197470532, 'z': 0.8477758065926903}, 0.73: {'y': 0.9852464094769928, 'z': 0.8438144694828539}, 0.74: {'y': 0.9957968744893131, 'z': 0.8398369451408635}, 0.75: {'y': 1.006925297258176, 'z': 0.8356480767175576}, 0.76: {'y': 1.0175156526998663, 'z': 0.8315275635449164}, 0.77: {'y': 1.0269731681756789, 'z': 0.8276034931203008}, 0.78: {'y': 1.0385007442632601, 'z': 0.8231974733041124}, 0.79: {'y': 1.049028891962811, 'z': 0.8189021333287714}, 0.8: {'y': 1.0583362286107856, 'z': 0.8148438263599547}, 0.81: {'y': 1.0694442941018336, 'z': 0.8103558057522162}, 0.82: {'y': 1.0795588888712024, 'z': 0.8060052029295569}, 0.83: {'y': 1.0892836169903306, 'z': 0.8016703251967148}, 0.84: {'y': 1.0999968235309705, 'z': 0.7970660757715348}, 0.85: {'y': 1.1100103210298504, 'z': 0.792618010415843}, 0.86: {'y': 1.1193049639522847, 'z': 0.7881998884088207}, 0.87: {'y': 1.1304361340436593, 'z': 0.7833456929133575}, 0.88: {'y': 1.1396325815021873, 'z': 0.7789170510178023}, 0.89: {'y': 1.1493193945777274, 'z': 0.7742485764458106}, 0.9: {'y': 1.1596353851212353, 'z': 0.769422445810134}, 0.91: {'y': 1.1698326663331784, 'z': 0.7645726939449126}, 0.92: {'y': 1.1790721543090534, 'z': 0.7598545225583713}, 0.93: {'y': 1.1880055506710743, 'z': 0.7552340675534406}, 0.94: {'y': 1.198794608488377, 'z': 0.7500574509951224}, 0.95: {'y': 1.207192953891004, 'z': 0.7454066541323496}, 0.96: {'y': 1.2174293071175608, 'z': 0.740265595359927}, 0.97: {'y': 1.2272467689710094, 'z': 0.7351694580628467}, 0.98: {'y': 1.2358146233740341, 'z': 0.7303507197842721}, 0.99: {'y': 1.2464060723918085, 'z': 0.7249136598471244}, 1.0: {'y': 1.25406582515682, 'z': 0.7202939613604683}, 1.01: {'y': 1.2649225292958324, 'z': 0.7146683131449285}, 1.02: {'y': 1.2731890501163012, 'z': 0.7096884938635056}, 1.03: {'y': 1.2821411288671087, 'z': 0.7045428822691568}, 1.04: {'y': 1.2922297024626441, 'z': 0.6989884579276908}, 1.05: {'y': 1.300347286890784, 'z': 0.6938840204180184}, 1.06: {'y': 1.3105493027116546, 'z': 0.6882195419944372}, 1.07: {'y': 1.3188662405853104, 'z': 0.6830172584566635}, 1.08: {'y': 1.3276990505516253, 'z': 0.6775289678892322}, 1.09: {'y': 1.3373579487434333, 'z': 0.6718955821747933}, 1.1: {'y': 1.3458851333325415, 'z': 0.6664545084169078}, 1.11: {'y': 1.3540563167990036, 'z': 0.661081235214536}, 1.12: {'y': 1.363996181409944, 'z': 0.6551164255137362}, 1.13: {'y': 1.3722764489772816, 'z': 0.6496420053674518}, 1.14: {'y': 1.3807991747090955, 'z': 0.643985864996684}, 1.15: {'y': 1.3892431751110013, 'z': 0.6383217407219507}, 1.16: {'y': 1.398227777225089, 'z': 0.6324753833928675},
        1.17: {'y': 1.4070110906566222, 'z': 0.6265832713664616}, 1.18: {'y': 1.4152050118248898, 'z': 0.62084004068961}, 1.19: {'y': 1.424213696755549, 'z': 0.6148211875186196},
        1.2: {'y': 1.4318142901343633, 'z': 0.6091886644934448}, 1.21: {'y': 1.4411766582919563, 'z': 0.6029033843391274}, 1.22: {'y': 1.4486481058696838, 'z': 0.597219990213234}, 1.23: {'y': 1.4575593227899915, 'z': 0.5910018937304705}, 1.24: {'y': 1.4658118074688808, 'z': 0.5849673118185954}, 1.25: {'y': 1.4739257929617988, 'z': 0.5788396801894846}, 1.26: {'y': 1.4821249711135962, 'z': 0.5727042279578212}, 1.27: {'y': 1.4906330199476778, 'z': 0.5664541605562727}, 1.28: {'y': 1.4982163833863493, 'z': 0.5604064158754787}, 1.29: {'y': 1.5068292584220941, 'z': 0.5539405252333741}, 1.3: {'y': 1.515024550802712, 'z': 0.5476079346360816}, 1.31: {'y': 1.5227052997669177, 'z': 0.5414175758610223}, 1.32: {'y': 1.5304640257754303, 'z': 0.5350885053777871},
        1.33: {'y': 1.5386933652014914, 'z': 0.5285696475260043}, 1.34: {'y': 1.5472488985203736, 'z': 0.5218846514617497}, 1.35: {'y': 1.5544602729740409, 'z': 0.5156561971838972}, 1.36: {'y': 1.5624236459752041, 'z': 0.5090662190320283}, 1.37: {'y': 1.5703049896843209, 'z': 0.5025130030732253}, 1.38: {'y': 1.577895042019525, 'z': 0.4959827677873189}, 1.39: {'y': 1.5857118080135988, 'z': 0.48926589585083324}, 1.4: {'y': 1.593103977878583, 'z': 0.4827410875185673}, 1.41: {'y': 1.6016960091815233, 'z': 0.47564384489930006}, 1.42: {'y': 1.608800890488085, 'z': 0.46904971100441134}, 1.43: {'y': 1.6162071150068176, 'z': 0.4624468065749081}, 1.44: {'y': 1.623851366837154, 'z': 0.4555621599077852}, 1.45: {'y': 1.631479234953679, 'z': 0.4485880792713057}, 1.46: {'y': 1.63902532847579, 'z': 0.4416709573087181}, 1.47: {'y': 1.6466175735572626, 'z': 0.43472411833077934}, 1.48: {'y': 1.6538074563038194, 'z': 0.42783084235268964}, 1.49: {'y': 1.6611967226956772, 'z': 0.420725789535342}, 1.5: {'y': 1.668661518033153, 'z': 0.4137084029725633}, 1.51: {'y': 1.6762712493229739, 'z': 0.4064913113831215}, 1.52: {'y': 1.6829544800269602, 'z': 0.39956768254053715}, 1.53: {'y': 1.6907951265065537, 'z': 0.3921753710478542}, 1.54: {'y': 1.6978998555009832, 'z': 0.38504159895504947}, 1.55: {'y': 1.70491723388297, 'z': 0.3778581875821891}, 1.56: {'y': 1.711865254189617, 'z': 0.3706504297777614}, 1.57: {'y': 1.7196452322820732, 'z': 0.3629959903257778}, 1.58: {'y': 1.7266904770267555, 'z': 0.3556787643735738}, 1.59: {'y': 1.7329901572058157, 'z': 0.3486218962633128}, 1.6: {'y': 1.7408787577503229, 'z': 0.3407894934905929}, 1.61: {'y': 1.7478981175637243, 'z': 0.3332866250797958}, 1.62: {'y': 1.7543437741662395, 'z': 0.3259795981944009}, 1.63: {'y': 1.7616771185386684, 'z': 0.3182900926391334}, 1.64: {'y': 1.7686777267597973, 'z': 0.31064987623872137}, 1.65: {'y': 1.775084778133109, 'z': 0.303169937980347}, 1.66: {'y': 1.7822595057008883, 'z': 0.29538195661524363}, 1.67: {'y': 1.7893089357152565, 'z': 0.2875369094073396}, 1.68: {'y': 1.7959164177834201, 'z': 0.2798053946294501}, 1.69: {'y': 1.8028258686585743, 'z': 0.27193057571048834}, 1.7: {'y': 1.8092306183963036, 'z': 0.2642985727961155}, 1.71: {'y': 1.8164139140550601, 'z': 0.25609399511017744}, 1.72: {'y': 1.8228412721110194, 'z': 0.2482791043709883}, 1.73: {'y': 1.8297284859047218, 'z': 0.24021344193905972}, 1.74: {'y': 1.8359195780460238, 'z': 0.232376340689348}, 1.75: {'y': 1.8430926609744298, 'z': 0.22396373419667387}, 1.76: {'y': 1.8494403140120068, 'z': 0.21600258589457416}, 1.77: {'y': 1.855771404417303, 'z': 0.2079419839939086}, 1.78: {'y': 1.862561008631592, 'z': 0.19952293687990932}, 1.79: {'y': 1.869142523068383, 'z': 0.1912404514912591}, 1.8: {'y': 1.8753594579287096, 'z': 0.18304703137760067}, 1.81: {'y': 1.882126789243069, 'z': 0.17445182944108073}, 1.82: {'y': 1.8885659677597095, 'z': 0.16602940381316458}, 1.83: {'y': 1.8946724119415033, 'z': 0.15772828577032394}, 1.84: {'y': 1.90132602023375, 'z': 0.14901656056541993}, 1.85: {'y': 1.9076049185372148, 'z': 0.1405047549941318}, 1.86: {'y': 1.91373529864162, 'z': 0.13197976612356233}, 1.87: {'y': 1.9203038567081954, 'z': 0.12305657095646677}, 1.88: {'y': 1.9265249851015938, 'z': 0.11432053466447066}, 1.89: {'y': 1.9326636241286232, 'z': 0.10563042328505418}, 1.9: {'y': 1.9389625885741932, 'z': 0.09669662970232742}, 1.91: {'y': 1.9451453574964055, 'z': 0.08773399893338535}, 1.92: {'y': 1.9512858736682521, 'z': 0.07875110380392575}, 1.93: {'y': 1.9575390731309423, 'z': 0.06953968068308725}, 1.94: {'y': 1.9637201694722646, 'z': 0.060325376012705274}, 1.95: {'y': 1.9697048525169742, 'z': 0.05117209514352039}, 1.96: {'y': 1.9757984416638998, 'z': 0.04183430496547645}, 1.97: {'y': 1.9819048918319588, 'z': 0.03233327400691231}, 1.98: {'y': 1.9879391064404275, 'z': 0.022795508420581846}, 1.99: {'y': 1.9938547427328632, 'z': 0.013303788152897993}}

    """### Path model flow

  # Wall call code
  """
    e = 0.8
    f = 0.1

    def Rebound(velocity_in, rotation_in, e, f):
        # this function calculates the after collision velocities and angular
        # velocities using crowe et al. 1997 equations, prior use of a change in
        # coordinates. Post collision velocities and rotation must be change back
        # to original coordinates right after this function
        rp = 0.5  # particle radious
        vx = velocity_in[0]
        vy = velocity_in[2]
        vz = velocity_in[1]

        rx = rotation_in[0]
        ry = rotation_in[2]
        rz = rotation_in[1]
        velocity_mod = math.sqrt(
            math.pow((vx + rp*rz), 2) + math.pow((vz-rp*rx), 2))
        value = -2/(7*f*(e+1))
        ex = (vx + rp*rz)/velocity_mod
        ez = (vz - rp*rx)/velocity_mod
        velocity_out = []
        rotation_out = []
        if vy/velocity_mod < value:
            swtch = 1
            velocity_out = [
                (5/7)*(vx - 2*rp/5*rz),
                (5/7)*(vz + 2*rp/5*rx),
                -e*vy
            ]
            rotation_out = [
                vz/rp,
                -velocity_out[0]/rp,
                ry
            ]
        else:
            swtch = 2
            velocity_out = [
                vx + ex*f*(e+1) * vy,
                vz + ez*f*(e+1) * vy,
                -e * vy
            ]
            rotation_out = [
                rx - 5/(2*rp)*ez*f*(e+1) * vy,
                rz + 5/(2*rp)*ex*f*(e+1) * vy,
                ry
            ]
        return velocity_out, rotation_out

    def wallcoll(velocity, rotation):
        one_angle = math.pi/180
        # if velocity[1] < 0:  #if v<0 then alfab has to be negative
        #    alfab = alfab * -1
        # if velocity[1] < 0:
        # %if v<0 gamab has to be negative
        #    gamab = gamab * -1
        # the rebound function (Crowe et al., 1998) needs a change of coordinates as
        # if the rebound was hapening in a flat bed
        gamab = (random.random()*(gamab_max - gamab_min) -
                 gamab_min) * one_angle
        titab = (random.random()*(titab_max - titab_min) +
                 titab_min) * one_angle
        return collision(velocity, rotation, titab, titab, gamab)

    def collision(in_velocity, in_rotation, alpha, theta, gamma):
        # Generating tranformation matrices
        [M, invM] = TransMat(alpha, theta, gamma)
        velocity = np.dot(M, in_velocity)  # vel in prime coord.
        rotation = np.dot(M, in_rotation)  # rot in prime coord.

        velocity_out, rotation_out = Rebound(
            velocity, rotation, e, f)  # %vel and rot after rebound

        # vel' in original coord.
        velocity_out = np.dot(invM, velocity_out).tolist()
        # rot' in original coord.
        rotation_out = np.dot(invM, rotation_out).tolist()
        return velocity_out, rotation_out

    # alpha / theta/gamma
    def TransMat(a, b, c):
        # This matrix transforms the rotated coordinates (titab and alfab) to
        # original coordinates, and the invM does the opposite
        M = np.array(
            [
                [math.cos(a)*math.cos(b), math.sin(a),
                 math.cos(a)*math.sin(b)],
                [-math.sin(c)*math.sin(b)-math.sin(a)*math.cos(c)*math.cos(b), math.cos(a)
                 * math.cos(c), math.sin(c)*math.cos(b)-math.sin(a)*math.cos(c)*math.sin(b)],
                [math.sin(a)*math.sin(c)*math.cos(b)-math.cos(c)*math.sin(b), -math.cos(a)
                 * math.sin(c), math.cos(c)*math.cos(b)+math.sin(a)*math.sin(c)*math.sin(b)]
            ]
        )

        invM = np.linalg.inv(M)
        return M, invM

    input_modelo_subida = []
    output_modelo_subida = []
    input_modelo_bajada = []
    output_modelo_bajada = []

    def get_high_point_prediction(velocity, rotation):
        input_model = velocity + rotation
        input_modelo_subida.append(input_model)
        input_model = np.array(input_model)
        input_model = input_model.reshape(6, 1).T
        prediction_detail = left_model.predict(input_model)
        prediction_detail = prediction_detail[0]
        prediction_detail[1] = abs(prediction_detail[1])
        output_modelo_subida.append(prediction_detail)
        return prediction_detail

    def get_end_point_prediction(z_position, velocity, rotation):
        input_model = [z_position - 0.5] + velocity + rotation
        input_modelo_bajada.append(input_model)
        input_model = np.array(input_model)
        input_model = input_model.reshape(7, 1).T
        prediction_detail = right_model.predict(input_model)
        prediction_detail = prediction_detail[0]
        output_modelo_bajada.append(prediction_detail)
        return prediction_detail

    def generate_left_path(starting_point, high_point):
        max_z_x_position = high_point[0]
        max_y = high_point[2]  # esta malo, hay que cambiar el modelo???
        max_z = high_point[1]
        y_sign = 0 if max_y == 0 else max_y/abs(max_y)
        path = []
        for key in base_left_path_data.keys():
            position = [
                key,
                base_left_path_data[key]['z'],
                base_left_path_data[key]['y']
            ]
            position[0] = position[0] * max_z_x_position
            position[1] = position[1] * (max_z)

            position[0] = position[0] + starting_point[0]
            position[1] = position[1] + starting_point[1]

            position[2] = abs(position[2] * max_y)
            position[2] = position[2] * y_sign
            position[2] = position[2] + starting_point[2]

            path.append(position)
        return path

    def generate_right_path(real_high_point, predicted_goal):
        max_x = predicted_goal[0]
        max_y = predicted_goal[2]
        max_z = real_high_point[1] - 0.5
        path = []
        for key in base_right_path_data.keys():
            position = [
                key,
                base_right_path_data[key]['z'],
                base_right_path_data[key]['y']
            ]
            position[0] = position[0] * max_x/2
            position[2] = position[2] * max_y/2
            position[1] = position[1] * max_z
            position[0] = position[0] + real_high_point[0]
            position[2] = position[2] + real_high_point[2]
            position[1] = position[1] + 0.5
            path.append(position)
        return path

    def get_up_information(last_velocity, last_rotation, last_point):
        to_low = True
        while(to_low):
            to_low = False
            high_point_prediction = get_high_point_prediction(
                last_velocity, last_rotation)
            # if high_point_prediction[2] < 0:
            #  high_point_prediction[2] *= -1
            last_velocity[1] = abs(last_velocity[1])
            last_velocity[0] = abs(last_velocity[0])
            # last_velocity, last_rotation = wallcoll(last_velocity, last_rotation)
        high_point = [high_point_prediction[0],
                      high_point_prediction[1], high_point_prediction[2]]
        high_point_velocity = [
            high_point_prediction[3], 0, high_point_prediction[4]]
        high_point_rotation = [high_point_prediction[5],
                               high_point_prediction[6], high_point_prediction[7]]
        left_points = generate_left_path(
            last_point, high_point)
        return {
            "velocity": high_point_velocity,
            "rotation": high_point_rotation,
            "path": left_points,
            "high_point_predicted": high_point
        }

    def model_up_jump(position, velocity, rotation):
        predicted_information = get_up_information(
            velocity, rotation, position)
        path = predicted_information['path']
        end_velocity = predicted_information['velocity']
        end_rotation = predicted_information['rotation']
        end_position = predicted_information['high_point_predicted']
        return path, end_velocity, end_rotation, end_position

    def model_down_jump(starting_position, velocity, rotation):
        predicted_information = get_end_point_prediction(
            starting_position[1], velocity, rotation)
        end_point = [predicted_information[0],
                     0.5,
                     predicted_information[1]
                     ]
        end_velocity = [predicted_information[2],
                        predicted_information[3],
                        predicted_information[4]]
        end_rotation = [predicted_information[5],
                        predicted_information[6],
                        predicted_information[7]]
        right_points = generate_right_path(starting_position, end_point)

        return end_point, right_points, end_velocity, end_rotation

    """##Flow with impact"""

    COLLISIONS = []
    CURRENT_POSITION = {}  # set of positions

    def hash_position(position):
        x_value = round(position[0], 1)
        y_value = round(position[1], 1)
        z_value = round(position[2], 1)
        hash_value = str(x_value) + str(y_value) + str(z_value)
        return hash_value

    def Update(velocity, position, delta_time):
        # Calculating the new particle location
        xp = position[0]+delta_time*velocity[0]
        yp = position[1]+delta_time*velocity[1]
        zp = position[2]+delta_time*velocity[2]
        return [xp, yp, zp]

    def collisions_particle_in_flow(old_velocity, old_rotation, impact_velocity, impact_rotation):
        one_angle = math.pi/180
        alpha = one_angle*(random.random()*88 - 0.41)
        theta = one_angle*(random.random()*44.50 - 30)
        gamma = one_angle*(random.random()*100 - 4)
        impact_velocity, impact_rotation = collision(
            impact_velocity, impact_rotation, alpha, theta, gamma)
        alpha = one_angle*(random.random()*88 - 0.41)
        theta = one_angle*(random.random()*44.50 - 30)
        gamma = one_angle*(random.random()*100 - 4)
        old_velocity, old_rotation = collision(
            old_velocity, old_rotation, alpha, theta, gamma)
        impact_velocity[0] = abs(impact_velocity[0])
        old_velocity[0] = abs(old_velocity[0])
        return old_velocity, old_rotation, impact_velocity, impact_rotation

    # CURRENT_POSITON
    # [ [velocity, rotation, particule_id],[velocity, rotation, particule_id],...]


    # True if the new position is free

    def check_next_position(particule, next_position):
        hash_new_position = hash_position(next_position)
        
        if hash_new_position in CURRENT_POSITION:
            return False
        CURRENT_POSITION[hash_new_position] = [
            particule['actual_velocity'],
            particule['actual_rotation'],
            particule['id']]
        return True

    class simulate_flow():
        def __init__(
                self, max_y=256, num_particles=20, time=TIME_LIMIT, check_y_border=True, impact=True):
            self.max_y = max_y*2
            self.num_particles = num_particles
            self.time = time
            self.check_y_border = check_y_border
            self.simulations = {}
            self.DT = 0.001

        def check_collision(self, particule, new_position):
            hash_new_position = hash_position(new_position)
            impact = False
            while hash_new_position in CURRENT_POSITION:
                # only one impact by step
                if not impact:
                    impact = True
                    old_velocity, old_rotation, velocity, rotation = collisions_particle_in_flow(
                        # velocity of particule on space
                        CURRENT_POSITION[hash_new_position][0],
                        # rotation of particule on space
                        CURRENT_POSITION[hash_new_position][1],
                        particule['actual_velocity'],
                        particule['actual_rotation']
                    )
                    simulation_old_id = CURRENT_POSITION[hash_new_position][2]
                    
                    CURRENT_POSITION[hash_new_position] = [
                        old_velocity, old_rotation, simulation_old_id]
                    self.simulations[simulation_old_id]["actual_velocity"] = old_velocity
                    self.simulations[simulation_old_id]["actual_rotation"] = old_rotation
                    self.simulations[simulation_old_id]["next_points"] = []
                    COLLISIONS.append({
                        'position': new_position.copy(),
                        'simulation_impact': particule['id'],
                        'simulation_to': simulation_old_id
                    })
                    print(new_position, particule['id'], simulation_old_id)
                new_position = Update(velocity, new_position, 0.01)
                while hash_position(new_position) == hash_new_position:
                    new_position = Update(velocity, new_position, 0.01)
                hash_new_position = hash_position(new_position)
            CURRENT_POSITION[hash_new_position] = [velocity, rotation, particule['id']]
            particule['actual_position'] = new_position
            particule['actual_velocity'] = velocity
            particule['actual_rotation'] = rotation
            particule["next_points"] = []
            return new_position

        def start(self, ignore_time = 0):
            self.generate_base_info()
            total_time = int(self.time/self.DT)
            #print(total_time)
            for i in range(0, int(ignore_time/self.DT)):
                self.next_step(collisions=False)

            for i in range(0, total_time):
                if i % 100 == 0:
                   print("step", float(i/self.time))
                self.next_step()
            return self.simulations

        def generate_base_info(self):
            for i in range(0, self.num_particles):
                # start_index = random.randint(0, len(case_detail_input_data_left - 1))
                # start_data = case_detail_input_data_left[start_index] #valid speed and rotation
                first_point = [
                    0 + random.random()*100, 
                    0.5 + random.random()*2,
                    random.random()*(self.max_y*2) - self.max_y
                ]
                first_velocity = [4.15, 1.85, 0.1]
                first_rotation = [0, 0, 0]
                particle = {
                    "actual_position": first_point,
                    "actual_velocity": first_velocity,
                    "actual_rotation": first_rotation,
                    "path": [first_point],
                    "points": [],
                    "up_points": [],
                    "end_points": [],
                    "high_points": [],
                    "id": i,
                    "down_distance": [],
                    "up_distance": [],
                    "tiempo_sube": [],
                    "tiempo_baja": [],
                    "tiempo_choque": [],
                }
                self.simulations[i] = particle

        def get_next_point(self, simulation):
            if 'time_position' not in simulation.keys():
                self.get_next_points(simulation)
            simulation['time_position'] += simulation['jump_distance']
            #print(simulation['time_position'], simulation['jump_distance'])
            index = round(simulation['time_position'])
            if index >= len(simulation['next_points']):
                time_start = time.time()
                self.get_next_points(simulation)
                total_time = time.time() - time_start
                if simulation['actual_velocity'][1]>0:
                    simulation['tiempo_sube'].append(total_time)
                else:
                    simulation['tiempo_baja'].append(total_time)
                return simulation['next_points'][0]
            try:     
                return simulation['next_points'][index]
            except:
            #    print(simulation['next_points'][0], index, len(simulation['next_points']))
                self.get_next_points(simulation)
                return simulation['next_points'][0] 

        # Move forward one step every particule
        # Check collision
        # IF there not more step, generate with model
        # based on the speed on y
        # If Vy> 0 then the particule is going up
        # Else particule is goind down

        def run_collision_check(self, simulation, next_position):
            print("checking collision")
            next_position = self.check_collision(simulation, next_position)
            # Perform any other actions you need with the updated next_position
        
        def next_step(self, collisions = True, batch_size = 10):
            simulation_keys = list(self.simulations.keys())
            total_simulations = len(simulation_keys)
            for i in range(0, total_simulations, batch_size):
                batch_keys = simulation_keys[i:i+batch_size]
                for simulation_key in batch_keys:
                    simulation = self.simulations[simulation_key]
                    next_position = self.get_next_point(simulation)
                    hash_old_position = hash_position(simulation['actual_position'])
                    simulation['actual_position'] = next_position

                    if hash_old_position in CURRENT_POSITION:
                        CURRENT_POSITION.pop(hash_old_position)
                    
                    #print("Printing",CURRENT_POSITION)
                    
                    if not collisions or check_next_position(simulation, next_position): # ignore collisions
                        simulation['actual_position'] = next_position
                        #print(next_position)
                    else:
                        #print("checking collision")
                        #next_position = self.check_collision(simulation, next_position)
                        collision_thread = threading.Thread(target=self.run_collision_check, args=(simulation, next_position))
                        collision_thread.start()
                        collision_thread.join()

                    simulation["path"].append(next_position)

        def get_jump_distance_by_DT(self, points, start_velocity, end_velocity):
            distance_x = points[-1][0] - points[0][0]
            #if distance_x < 0:
            #    print(points[-1],points[0])
            
            time_x =len(points)/( distance_x/((end_velocity[0]+start_velocity[0])/2)/self.DT)
            #if time_x < 0:
            #    print(start_velocity, end_velocity)
            #    print("aaaaaaaa")
            return time_x

        def get_next_points(
                self, simulation, velocity=None, rotation=None, fixing=0):
            #print("START fixing",fixing)
            #fixing 0 -> No fix, 1 -> UP 2-> Down
            position = simulation['actual_position']
            if velocity is None:
                velocity = simulation['actual_velocity']
            if rotation is None:
                rotation = simulation['actual_rotation']
            if velocity[1] > 0:
                jump_points, end_velocity, end_rotation, jump_up_point = model_up_jump(
                    position, velocity, rotation)
                if jump_up_point[0] < 0 or jump_up_point[1] <= 0.1:
                    if not fixing:
                        fixing = 1
                    # print("Invalid UP JUMP")
                    # print(jump_up_point, end_velocity)
                    output_modelo_subida.pop()
                    input_modelo_subida.pop()
                    #print("fail 1", fixing,simulation["id"])
                    return self.get_next_points(
                        simulation, end_velocity, end_rotation, fixing)
                if fixing in [0,1]:
                    simulation['up_points'].append(jump_up_point)
                    end_position = [position[0] + jump_up_point[0],
                                    position[1] + jump_up_point[1],
                                    position[2] + jump_up_point[2]]
                    simulation['high_points'].append(end_position[1])
                    simulation['up_distance'].append(jump_up_point[0])
                else:
                    output_modelo_subida.pop()
                    input_modelo_subida.pop()
                    #print("fixing 1", fixing)
                    return self.get_next_points(
                        simulation, end_velocity, end_rotation, fixing)
            else:
                end_point, jump_points, end_velocity, end_rotation = model_down_jump(
                    position, velocity, rotation)
                time_start = time.time()
                end_velocity, end_rotation = wallcoll(
                    end_velocity, end_rotation)
                simulation['tiempo_choque'].append(time.time() - time_start)
                # Add check after impact floor particule should go up
                if end_point[0] < 0:
                    if not fixing:
                        fixing = 2
                    output_modelo_bajada.pop()
                    input_modelo_bajada.pop()
                    #print("fail 2", fixing,simulation["id"])
                    return self.get_next_points(
                        simulation, end_velocity, end_rotation, fixing)
                if fixing in [0,2]:
                    simulation['end_points'].append(end_point)
                    simulation['down_distance'].append(end_point[0])
                    end_position = [position[0] + end_point[0],
                                    end_point[1],
                                    position[2] + end_point[2]
                                    ]
                else:
                    #print("fixing 2", fixing)
                    output_modelo_bajada.pop()
                    input_modelo_bajada.pop()
                    return self.get_next_points(
                        simulation, end_velocity, end_rotation, fixing)
                # print("DOWN",end_position, end_velocity)
            simulation["points"].append(end_position)
            jump_distance = self.get_jump_distance_by_DT(jump_points, velocity, end_velocity)
            simulation['path'] += jump_points
            simulation['actual_velocity'] = end_velocity
            simulation['actual_rotation'] = end_rotation
            simulation['jump_distance'] = jump_distance
            simulation['time_position'] = 0
            # Add points to global list
            simulation['next_points'] = jump_points
    
    now = datetime.now()
    input_modelo_subida = []
    output_modelo_subida = []
    input_modelo_bajada = []
    output_modelo_bajada = []
    starting_time = now.strftime("%H:%M:%S")
    simulations = simulate_flow(num_particles=NUM_Particules, time=TIME_LIMIT).start()
    now = datetime.now()
    end_time = now.strftime("%H:%M:%S")
    data = generate_data(input_modelo_subida, output_modelo_subida,
                         input_modelo_bajada, output_modelo_bajada)
    data['simulations'] =[]
    data['tiempo_sube'] = []
    data['tiempo_baja'] = []
    data['tiempo_choque'] = []
    data["collisions"] = COLLISIONS
    for simulation in simulations.values():
        data['simulations'].append(simulation['path'])
        data['tiempo_sube'].append(simulation['tiempo_sube'])
        data['tiempo_baja'].append(simulation['tiempo_baja'])
        data['tiempo_choque'].append(simulation['tiempo_choque'])
    return {
        'starting_time': starting_time,
        'end_time': end_time,
        'jumps_count': len(data['high_values']),
        'data': data
    }


def generate_data(
        input_modelo_subida, output_modelo_subida,
        input_modelo_bajada, output_modelo_bajada):
    high_values = []
    distance_up = []
    distance_down = []
    starting_velocity_up_x = []
    starting_velocity_up_y = []
    starting_velocity_up_z = []
    starting_rotation_up_x = []
    starting_rotation_up_y = []
    starting_rotation_up_z = []

    end_velocity_up_x = []
    end_velocity_up_y = []
    end_velocity_up_z = []
    end_rotation_up_x = []
    end_rotation_up_y = []
    end_rotation_up_z = []

    starting_velocity_down_x = []
    starting_velocity_down_y = []
    starting_velocity_down_z = []
    starting_rotation_down_x = []
    starting_rotation_down_y = []
    starting_rotation_down_z = []

    end_velocity_down_x = []
    end_velocity_down_y = []
    end_velocity_down_z = []
    end_rotation_down_x = []
    end_rotation_down_y = []
    end_rotation_down_z = []
    right_jumps = 0
    left_jumps = 0

    for case in input_modelo_subida[20:]:
        starting_velocity_up_x.append(float(case[0]))
        starting_velocity_up_y.append(float(case[1]))
        starting_velocity_up_z.append(float(case[2]))
        starting_rotation_up_x.append(float(case[3]))
        starting_rotation_up_y.append(float(case[4]))
        starting_rotation_up_z.append(float(case[5]))

    for case in output_modelo_subida[20:]:
        distance_up.append(float(case[0]))
        if case[1] > 0.1:
            high_values.append(float(case[1]))
            end_velocity_up_x.append(float(case[3]))
            end_velocity_up_z.append(float(case[4]))
            end_rotation_up_x.append(float(case[5]))
            end_rotation_up_y.append(float(case[6]))
            end_rotation_up_z.append(float(case[7]))
            if case[2] > 0:
                right_jumps += 1
            else:
                left_jumps += 1

    for case in input_modelo_bajada[20:]:
        starting_velocity_down_x.append(float(case[1]))
        starting_velocity_down_y.append(float(case[2]))
        starting_velocity_down_z.append(float(case[3]))
        starting_rotation_down_x.append(float(case[4]))
        starting_rotation_down_y.append(float(case[5]))
        starting_rotation_down_z.append(float(case[6]))

    for case in output_modelo_bajada[20:]:
        distance_down.append(float(case[0]))
        end_velocity_down_x.append(float(case[2]))
        end_velocity_down_y.append(float(case[3]))
        end_velocity_down_z.append(float(case[4]))
        end_rotation_down_x.append(float(case[5]))
        end_rotation_down_y.append(float(case[6]))
        end_rotation_down_z.append(float(case[7]))

    data = {
        'high_values': high_values,
        'distance_up': distance_up,
        'distance_down': distance_down,
        'starting_velocity_up_x': starting_velocity_up_x,
        'starting_velocity_up_y': starting_velocity_up_y,
        'starting_velocity_up_z': starting_velocity_up_z,
        'starting_rotation_up_x': starting_rotation_up_x,
        'starting_rotation_up_y': starting_rotation_up_y,
        'starting_rotation_up_z': starting_rotation_up_z,
        'end_velocity_up_x': end_velocity_up_x,
        'end_velocity_up_y': end_velocity_up_y,
        'end_rotation_up_x': end_rotation_up_x,
        'end_rotation_up_y': end_rotation_up_y,
        'end_rotation_up_z': end_rotation_up_z,
        'starting_velocity_down_x': starting_velocity_down_x,
        'starting_velocity_down_y': starting_velocity_down_y,
        'starting_velocity_down_z': starting_velocity_down_z,
        'starting_rotation_down_x': starting_rotation_down_x,
        'starting_rotation_down_y': starting_rotation_down_y,
        'starting_rotation_down_z': starting_rotation_down_z,
        'end_velocity_down_x': end_velocity_down_x,
        'end_velocity_down_y': end_velocity_down_y,
        'end_velocity_down_z': end_velocity_down_z,
        'end_rotation_down_x': end_rotation_down_x,
        'end_rotation_down_y': end_rotation_down_y,
        'end_rotation_down_z': end_rotation_down_z}
    return data


file_result_name = 'result_1.json'
results = []
for gamab_max in [60]:
    for gamab_min in [-60]:
        for titab_max in [30]:
            for titab_min in [10]:
                for max_time in [10]:
                    for n_part in [1]:
                        print("Executing model")
                        start = time.time()
                        execution_details = execute_flow(
                            gamab_max, gamab_min, titab_max, titab_min, max_time, n_part)
                        end = time.time()
                        print(n_part, end-start)
                        #print(max_time,
                        #    execution_details['starting_time'],
                        #    execution_details['end_time'],
                        #    execution_details['jumps_count'],
                        #    np.average(execution_details['data']['high_values']),
                        #    np.average(execution_details['data']['distance_up']),
                        #    np.average(
                        #        execution_details['data']['distance_down']),
                        #    gamab_max, gamab_min, titab_max, titab_min,   
                        #)
                        results.append(execution_details)

#json_string = json.dumps(results)
#with open(file_result_name, 'w') as outfile:
#    outfile.write(json_string)
